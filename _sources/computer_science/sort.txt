排序算法
==========


快速排序算法
------------

算法复杂度
^^^^^^^^^^^^^^^

快速排序的时间复杂度为θ(n2),虽然最坏情况下时间复杂度很差，但快速排序通常在实际应用中是最好的选择，因为他的平均性能好。


算法基本思想
^^^^^^^^^^^^^^^^


* 分解
	
	将数组A[p..r]划分为两个（可能为空）子数组A[p, q-1] 和 A[q+1, r]。使得A[p, q-1]中的每个元素小于等于A[q], A[q+1, r]中的每个元素大于等于A[q];

* 解决

	通过递归调用快速排序，对子数组A[p, q-1] 和 A[q+1, r]进行排序。

* 归并
	
	因为子数组都是原址排序的，所以不需要合并操作


伪代码
^^^^^^^^^

.. code-block:: c++

    QUICK_SORT(A, p, r):
        if(p < r)
            q = PARTITION(A, p, r)
            QUICK_SORT(A, p, q-1)
            QUICK_SORT(A, q+1, r)


    PARTITION(A, p, r)
        x = A[r]
        i = p-1
        for j = p to r-1
            if A[j] <= x
                i = i+1
                exchange A[i] with A[j]

    exchange A[i+1] with A[r]
    return i+1


快速排序的随机化版本
^^^^^^^^^^^^^^^^^^^^^^^

上面的版本中A[r]称作主元，在随机化版本里面，主元是随机抽取。然后跟A[r]交换。

.. code-block:: c++

	RANDOMIZED-PARTITION(A, p, r)
		i = RANDOM(p, r)
		exchange A[i] with A[r]

随机化版本性能
^^^^^^^^^^^^^^^

TO-DO

			
冒泡排序算法
------------

算法复杂度
^^^^^^^^^^^^

冒牌排序的算法复杂度是O(n2)

算法基本思想
^^^^^^^^^^^^^

每次比较相邻元素，如果左边元素大于右边元素，则交换这两个元素。外层循环每循环一次，最大的元素排到队尾。


伪代码
^^^^^^^^^^^^

.. code-block:: c++

    BUBBLE_SORT(A):
        for i = 1  to A.length
            for j = 0 to A.length - i
                if A[j] > A[j+1]
                    exchange A[j] with A[j+1]


改进
^^^^^^

如果序列中大部分元素已经是递增的顺序，经过前面几次循环后可能整个序列已排好序。这时后面的循环只有比较而没有交换。这时，可以在
程序中增加一个flag来标记某次外层的循环有没有发生数据交换。如果没有，跳出循环，排序过程结束。


插入排序
--------

算法复杂度
^^^^^^^^^^^^

最坏情况下的算法时间复杂度是θ(n2)。对少量元素的排序，它是一个有效的算法。

算法基本思想
^^^^^^^^^^^^^

插入排序就像玩扑克牌，从桌子上抓到一张牌，然后从右向左将他于手中已经排好序的牌比较，最后放入正确的位置。

伪代码
^^^^^^^

.. code-block:: c++

    INSERT_SORT(A)
        for j = 2 to A.length
            key = A[j]
            i = j-1
            while i > 0 and A[i] > key
                A[i+1] = A[i]
                i = i - 1
            A[i+1] = key;


归并排序
--------