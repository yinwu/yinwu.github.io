Regular Expression
==================================

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern), 
可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。


普通字符
----------------

没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

非打印字符
-----------------

**\\f** 换页符

**\\n** 换行符

**\\r** 回车符

**\\s** 匹配任何空白字符，等价与[\\f\\n\\r\\t\\v]

**\\S** 匹配任何非空白字符等价与[^\\f\\n\\r\\t\\v]

**\\t** 制表符

**\\v** 垂直制表符

特殊字符
-----------------


**$**  匹配字符串结尾的位置

**()** 匹配一个子表达式开始和结束的位置，子表达式可以获取供以后使用。

**\*** 匹配前面的子表达式零次或者多次。

**+** 匹配前面子表达式一次或者多次。

**.** 匹配除换行符之外的任意单字符。

**?** 匹配前面的子表达式零次或者一次，或指明一个非贪婪限定符。

**\\** 将下一个字符标记为特殊字符，或者原义字符。

**[** 标记一个中括号表达式的开始。

**^** 匹配字符串的开始位置。如果在方括号表达式使用的话，表示对该字符集取反。

**{** 标记限定符表达式的开始。

**|** 表示两项之间的一个选择。

元字符
-------------------

**(pattern)** 匹配 pattern 并获取这一匹配。

**(?:pattern)** 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。

**(?=pattern)**

	正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。
	
	这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
	
	例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。
	
	预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

**(?!pattern)**

	正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。
	
	这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
	
	例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。
	
	预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
	
**(?<=pattern)**

	反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。
	
	例如，"(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。
	
**(?<!pattern)**

	反向否定预查，与正向否定预查类似，只是方向相反。
	
	例如"(?<!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。

**x|y** 匹配x或y。

**[xyz]** 字符集合。匹配所包含的任意一个字符。

**[^xyz]** 负值字符集合。匹配未包含的任意字符。

**[a-z]** 字符范围。匹配指定范围内的任意字符。

**[^a-z]** 负值字符范围。匹配任何不在指定范围内的任意字符。

**\\d** 匹配一个数字字符。等价于 [0-9]。

**\\D** 匹配一个非数字字符。等价于 [^0-9]。

**\\w** 匹配字母、数字、下划线。等价于 "[A-Za-z0-9_]"。

**\\W** 匹配非字母、数字、下划线。等价于 "[^A-Za-z0-9_]"。


	
限定符
---------------------

限定符表示表示正则表达式给定组件必须出现多少次才满足匹配

	**\*** 匹配前面的子表达式零次或者多次

	**+** 匹配前面子表达式一次或者多次。

	**?** 匹配前面的子表达式零次或者一次。

	**{n}**, 匹配N次

	**{n,}** 至少匹配N次

	**{m, n}** 最少匹配n次，最多匹配m次。


贪婪匹配和非贪婪匹配
-------------------------

限定符默认都是贪婪的，通过在 \*、+ 或 ? 限定符之后放置 ?，该表达式从"贪心"表达式转换为"非贪心"表达式或者最小匹配。

.. code-block:: html

	<H1>Chapter 1 - 介绍正则表达式</H1>


**贪婪** 

.. code-block:: console

	/<.*>/


尽可能多的匹配,匹配的结果是“<H1>Chapter 1 - 介绍正则表达式</H1>”

**非贪婪** 

.. code-block:: console

	/<.*?>/


只要匹配完成，就结束匹配过程。匹配的结果时<H1>
	
	
定位符
-------------------

	**^** 匹配字符串开头的位置。

	**$** 匹配字符串结尾的位置。

	**\b** 匹配一个字的边界。

		字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。
		如果它位于字符串的结尾，它在单词的结尾处查找匹配项。
		
		**"/\\bCha/"** 匹配Chapter前三个字母。**"/ter\\b/"** 匹配Chapter后三个字母。
		
	**\B** 非字边界匹配。

		**"/\\Bapt/"** 匹配Chapter中的apt三个字符，并不匹配aptitude中的apt三个字符，也不匹配adapt中的后三个字母。
	
	
选择
---------

	用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。
	但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。


反向引用
----------

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。
	
可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 

.. code-block:: html

	var str = "Is is the cost of of gasoline going up up";
	var patt1 = /\b([a-z]+) \1\b/ig;
	document.write(str.match(patt1));


捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。

正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。

字边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。

正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。

表达式的结尾处的不区分大小写 i 标记指定不区分大小写。

多行标记指定换行符的两边可能出现潜在的匹配。
	
运算符优先级
-------------------

#. 转移符\

#. 圆括号和方括号 (), (?:), (?=), []

#. 限定符 \*, +, ?, {n}, {n,}, {n,m}

#. 定位点和序列（即：位置和顺序）: ^, $, \任何元字符、任何字符

#. 替换，"或"操作 |

	

